
/* Class = "NSButtonCell"; title = "AppleImageConversion"; ObjectID = "0AM-nb-Yrd"; */
"0AM-nb-Yrd.title" = "AppleImageConversion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple audio protocols with builtin versions.\nApple audio protocols allow macOS bootloader and OpenCore to play sounds and signals for screen reading or\naudible error reporting. Supported protocols are beep generation and VoiceOver. VoiceOver protocol is specific to Gibraltar machines (T2) and is not supported before macOS High Sierra (10.13). Instead older macOS versions use AppleHDA protocol, which is currently not implemented.\n\nOnly one set of audio protocols can be available at a time, so in order to get audio playback in OpenCore user interface on Mac system implementing some of these protocols this setting should be enabled.\n\nNote: Backend audio driver needs to be configured in UEFI Audio section for these protocols to be able to stream audio."; ObjectID = "0RZ-LX-aI2"; */
"0RZ-LX-aI2.ibShadowedToolTip" = "Réinstallez Apple Audio Protocol avec la version intégrée. \n Le protocole audio Apple permet au chargeur de démarrage macOS et à OpenCore de lire des sons et des signaux pour la lecture d'écran ou le signalement des erreurs sonores. \n Les protocoles pris en charge sont la génération de bips et VoiceOver. Non pris en charge avant macOS High Sierra (10.13). En revanche, les versions antérieures de macOS utilisaient le protocole AppleHDA, qui n'est pas actuellement implémenté. \n  \n Pour obtenir la lecture audio dans l'interface utilisateur OpenCore sur les systèmes Mac qui implémentent certains protocoles, ce paramètre doit être activé. \n  \n Remarque: vous devez configurer le pilote audio principal dans la section UEFI-> Audio pour que ces protocoles fonctionnent.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: NO\nDescription: Some types of firmware (such as APTIO IV) may contain invalid values in the MSR_FLEX_RATIO (0x194) MSR register. These values may cause macOS boot failures on Intel platforms.\n\nNote: While the option is not expected to harm unaffected firmware, its use is only recommended when it is specifically required."; ObjectID = "0Sc-nS-2YL"; */
"0Sc-nS-2YL.ibShadowedToolTip" = "Si vous n'avez pas déverrouillé CFG dans le bios, assurez-vous de sélectionner OUI.";

/* Class = "NSTextFieldCell"; title = "AudioDevice"; ObjectID = "0gM-HU-fz5"; */
"0gM-HU-fz5.title" = "AudioDevice";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Attempts to perform TSC synchronisation with a specified timeout.\n\nThe primary purpose of this quirk is to enable early bootstrap TSC synchronisation on some server and laptop models when running a debug XNU kernel. For the debug kernel the TSC needs to be kept in sync across the cores before any kext could kick in rendering all other solutions problematic. The timeout is specified in microseconds and depends on the amount of cores present on the platform, the recommended starting value is 500000.\n\nThis is an experimental quirk, which should only be used for the aforementioned problem. In all other cases the quirk may render the operating system unstable and is not recommended. The recommended solution in the other cases is to install a kernel driver such as VoodooTSCSync, TSCAdjustReset, or CpuTscSync (a more specialised variant of VoodooTSCSync for newer laptops).\n\nNote: The reason this quirk cannot replace the kernel driver is because it cannot operate in ACPI S3 mode (sleep wake) and because the UEFI firmware provides very limited multicore support preventing the precise update of the MSR registers."; ObjectID = "0un-PF-SFE"; */
"0un-PF-SFE.ibShadowedToolTip" = "Type: entier plist \nFailsafe: 0 \nDescription: tente d'effectuer la synchronisation TSC avec un délai spécifié. \nLe but principal de cette bizarrerie est d'activer la synchronisation TSC bootstrap précoce sur certains modèles de serveur et d'ordinateur portable lors de l'exécution d'un noyau de débogage XNU. Pour le noyau de débogage, le TSC doit être synchronisé entre les cœurs avant que n'importe quel kext ne puisse rendre problématique toutes les autres solutions. Le délai d'expiration est spécifié en microsecondes et dépend de la quantité de cœurs présents sur la plate-forme, la valeur de départ recommandée est 500000. \nCeci est une bizarrerie expérimentale, qui ne devrait être utilisée que pour le problème susmentionné. Dans tous les autres cas, la bizarrerie peut rendre le système d'exploitation instable et n'est pas recommandée. La solution recommandée dans les autres cas consiste à installer un pilote de noyau comme VoodooTSCSync, TSCAdjustReset ou CpuTscSync (une variante plus spécialisée de VoodooTSCSync pour les ordinateurs portables plus récents). \n \nRemarque: la raison pour laquelle cette bizarrerie ne peut pas remplacer le pilote du noyau est parce qu'elle ne peut pas fonctionner en mode ACPI S3 (veille de veille) et parce que les firmwares UEFI fournissent un support multicœur très limité empêchant la mise à jour précise des registres MSR.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Play chime sound at startup.\n\nEnabling this setting plays boot chime through builtin audio support. Volume level is determined by MinimumVolume and VolumeAmplifier settings and SystemAudioVolume NVRAM variable.\n\nNote: this setting is separate from StartupMute NVRAM variable to avoid conflicts when the firmware is able to play boot chime."; ObjectID = "10Z-Yt-6vt"; */
"10Z-Yt-6vt.ibShadowedToolTip" = "Jouez le bip de Duang au démarrage. \n Remarque: ce paramètre est distinct de la variable StartupMute NVRAM pour éviter les conflits lorsque le micrologiciel peut lire la sonnerie de démarrage.";

/* Class = "NSButtonCell"; title = "EnableJumpstart"; ObjectID = "133-jD-qYy"; */
"133-jD-qYy.title" = "EnableJumpstart";

/* Class = "NSButtonCell"; title = "DeduplicateBootOrder"; ObjectID = "1BB-1W-mfl"; */
"1BB-1W-mfl.title" = "DeduplicateBootOrder";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reconnect console controllers after changing screen resolution.\n\nOn some types of firmware, the controllers that produce the console protocols (simple text out) must be reconnected when the screen resolution is changed via GOP. Otherwise they will not produce text based on the new resolution.\n\nNote: On several boards this logic may result in black screen when launching OpenCore from Shell and thus it is optional. In versions prior to 0.5.2 this option was mandatory and not configurable. Please do not use this unless required."; ObjectID = "1QT-lu-i79"; */
"1QT-lu-i79.ibShadowedToolTip" = "Certains micrologiciels nécessitent de reconnecter le contrôleur pour afficher le texte après la modification de la résolution GOP. L'activation de cette option entraînera la disparition de l'écran lors du démarrage d'OpenCore à partir du shell UEFI. \n Si vous rencontrez un écran noir jusqu'à l'écran de connexion, veuillez essayer de sélectionner OUI.";

/* Class = "NSButtonCell"; title = "ForceResolution"; ObjectID = "2kV-J6-o4B"; */
"2kV-J6-o4B.title" = "ForceResolution";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Activate audio support by connecting to a backend driver.\n\nEnabling this setting routes audio playback from builtin protocols to a dedicated audio port (AudioOut) of the specified codec (AudioCodec) located on the audio controller (AudioDevice)."; ObjectID = "2zI-kW-5dk"; */
"2zI-kW-5dk.ibShadowedToolTip" = "Activez la prise en charge audio en vous connectant à un pilote principal (vous devez ajouter le pilote AudioDxe.efi). \n  \n Activez ce paramètre pour router la lecture audio du protocole intégré vers le port audio dédié (AudioOut) du codec spécifié (AudioCodec) situé sur le contrôleur audio (AudioDevice).";

/* Class = "NSButtonCell"; title = "HashServices"; ObjectID = "33a-jy-EES"; */
"33a-jy-EES.title" = "HashServices";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Request redirect of all Boot prefixed variables from EFI_GLOBAL_VARIABLE_GUID to OC_VENDOR_VARIABLE_GUID.\n\nThis quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi. The quirk lets default boot entry preservation at times when the firmware deletes incompatible boot entries. In summary, this quirk is required to reliably use the Startup Disk preference pane in firmware that is not compatible with macOS boot entries by design."; ObjectID = "3Q0-sm-ooL"; */
"3Q0-sm-ooL.ibShadowedToolTip" = "Activez cette option pour permettre une utilisation fiable du paramètre [disque de démarrage] dans le micrologiciel qui n'est pas compatible avec la conception d'entrée de démarrage macOS. \n Il est également lié à la mémorisation de la fonction d'entrée de démarrage par défaut, il est recommandé d'utiliser OUI";

/* Class = "NSTextFieldCell"; title = "TimerResolution"; ObjectID = "3Ql-TM-Oiv"; */
"3Ql-TM-Oiv.title" = "TimerResolution";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Set OEM protocol used for internal pointer driver.\nCurrently the only supported variant is ASUS, using specialised protocol available on select Z87 and Z97 ASUS boards."; ObjectID = "3mi-sh-qNa"; */
"3mi-sh-qNa.ibShadowedToolTip" = "Généralement laissé vide \n Il utilise certains protocoles propriétaires disponibles sur les cartes ASUS Z87 et Z97.";

/* Class = "NSButtonCell"; title = "RequestBootVarRouting"; ObjectID = "4Eq-ma-JKy"; */
"4Eq-ma-JKy.title" = "RequestBootVarRouting";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls unicode collation services with builtin version. Should be set to true to ensure UEFI Shell compatibility on platforms providing broken unicode collation. In general legacy Insyde and APTIO platforms on Ivy Bridge and earlier are affected."; ObjectID = "4bg-ao-G40"; */
"4bg-ao-G40.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Certains firmwares plus anciens rompent le classement Unicode. Le réglage sur YES peut corriger la compatibilité du shell UEFI sur ces systèmes (généralement pour IvyBridge ou des appareils plus anciens) ";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal keyboard input translation to AppleKeyMapAggregator protocol.\nThis option activates the internal keyboard interceptor driver, based on AppleGenericInput aka AptioIntput), to fill AppleKeyMapAggregator database for input functioning. In case a separate driver is used, such as OpenUsbKbDxe, this option should never be enabled."; ObjectID = "4fK-xq-9AN"; */
"4fK-xq-9AN.ibShadowedToolTip" = "Activez la prise en charge du clavier intégré d'OC. Certains ordinateurs portables ne peuvent pas utiliser le clavier dans l'interface du menu de démarrage. Veuillez le sélectionner! \n Si vous utilisez AppleUsbKbdxe.efi, veuillez définir NON";

/* Class = "NSTabViewItem"; label = "Audio"; ObjectID = "5Gm-fv-IpR"; */
"5Gm-fv-IpR.label" = "Audio";

/* Class = "NSButtonCell"; title = "JumpstartHotPlug"; ObjectID = "6B4-NA-lHR"; */
"6B4-NA-lHR.title" = "JumpstartHotPlug";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "6k6-uj-n97"; */
"6k6-uj-n97.headerCell.title" = "Commentaire";

/* Class = "NSTableView"; ibShadowedToolTip = "Type: plist array\nDefault value: None\nDescription: Load selected drivers from OC/Drivers directory.\nDesigned to be filled with string filenames meant to be loaded as UEFI drivers. Depending on the firmware a different set of drivers may be required. Loading an incompatible driver may lead your system to unbootable state or even cause permanent firmware damage. Some of the known drivers include:\n• AudioDxe — HDA audio support driver in UEFI firmwares for most Intel and some other analog audio controllers.\n• ExFatDxe — Proprietary ExFAT file system driver for Bootcamp support commonly found in Apple firmwares. For Sandy Bridge and earlier CPUs ExFatDxeLegacy driver should be used due to the lack of RDRAND instruction support.\n• HfsPlus — Proprietary HFS file system driver with bless support commonly found in Apple firmwares. For Sandy Bridge and earlier CPUs HfsPlusLegacy driver should be used due to the lack of RDRAND instruction support.\n• HiiDatabase* — HII services support driver from MdeModulePkg. This driver is included in most firmwares starting with Ivy Bridge generation. Some applications with the GUI like UEFI Shell may need this driver to work properly.\n• EnhancedFatDxe — FAT filesystem driver from FatPkg. This driver is embedded in all UEFI firmwares, and cannot be used from OpenCore. It is known that multiple firmwares have a bug in their FAT support implementation, which leads to corrupted filesystems on write attempt. Embedding this driver within the firmware may be required in case writing to EFI partition is needed during the boot process.\n• NvmExpressDxe — NVMe support driver from MdeModulePkg. This driver is included in most firmwares starting with Broadwell generation. For Haswell and earlier embedding it within the firmware may be more favourable in case a NVMe SSD drive is installed.\nOpenCanopy* — OpenCore plugin implementing graphical interface.\nOpenRuntime* — OpenCore plugin implementing OC_FIRMWARE_RUNTIME protocol.\n• OpenUsbKbDxe* — USB keyboard driver adding the support of AppleKeyMapAggregator protocols on top of a custom USB keyboard driver implementation. This is an alternative to builtin KeySupport, which may work better or worse depending on the firmware.\n• Ps2KeyboardDxe* — PS/2 keyboard driver from MdeModulePkg. DuetPkg OpenDuetPkg and some firmwares may not include this driver, but it is necessary for PS/2 keyboard to work. Note, un- like OpenUsbKbDxe this driver has no AppleKeyMapAggregator support and thus requires KeySupport to be enabled.\n• Ps2MouseDxe* — PS/2 mouse driver from MdeModulePkg. Some very old laptop firmwares may not include this driver, but it is necessary for touchpad to work in UEFI graphical interfaces, such as OpenCanopy.\n• UsbMouseDxe* — USB mouse driver from MdeModulePkg. Some virtual machine firmwares like OVMF may not include this driver, but it is necessary for mouse to work in UEFI graphical interfaces, such as OpenCanopy.\n• VBoxHfs — HFS file system driver with bless support. This driver is an alternative to a closed source HfsPlus driver commonly found in Apple firmwares. While it is feature complete, it is approximately 3 times slower and is yet to undergo a security audit.\n• XhciDxe* — XHCI USB controller support driver from MdeModulePkg. This driver is included in most firmwares starting with Sandy Bridge generation. For earlier firmwares or legacy systems it may be used to support external USB 3.0 PCI cards.\n\nDriver marked with * are bundled with OpenCore. To compile the drivers from UDK (EDK II) use the same command you do normally use for OpenCore compilation, but choose a corresponding package:\ngit clone https://github.com/acidanthera/audk UDK cd UDK\nsource edksetup.sh\nmake -C BaseTools\nbuild -a X64 -b RELEASE -t XCODE5 -p FatPkg/FatPkg.dsc\nbuild -a X64 -b RELEASE -t XCODE5 -p MdeModulePkg/MdeModulePkg.dsc"; ObjectID = "6zo-Jl-Ryl"; */
"6zo-Jl-Ryl.ibShadowedToolTip" = "Chargez les pilotes sélectionnés à partir du répertoire OC / Drivers. \n Notez l'ordre de remplissage \n Selon le matériel, différents pilotes peuvent être nécessaires. Le chargement de pilotes incompatibles peut entraîner un démarrage impossible du système ou même endommager définitivement le micrologiciel. Certains pilotes connus incluent: \n  • Pilote de démarrage du système de fichiers ApfsDriverLoader-APFS. Ajout de la prise en charge des pilotes APFS intégrés dans le conteneur APFS amorçable du micrologiciel UEFI. \n  • FwRuntimeServices - Améliore la sécurité d'OpenCore et de Lilu en prenant en charge les variables NVRAM en lecture seule et en lecture seule. Certaines bizarreries (telles que RequestBootVarRouting) nécessitent ce pilote pour fonctionner correctement. En raison de la nature du pilote d'exécution en temps réel, qui s'exécute en parallèle avec le système d'exploitation cible, il ne peut pas être implémenté dans OpenCore lui-même, mais est fourni avec la distribution OpenCore. \n  • Pilote du système de fichiers EnhancedFatDxe-FatPkg FAT. Ce pilote est intégré à tous les micrologiciels UEFI et ne peut pas être utilisé à partir d'OpenCore. Comme nous le savons tous, il existe des erreurs dans la mise en œuvre de la prise en charge FAT pour divers micrologiciels, ce qui peut endommager le système de fichiers lors de la tentative d'écriture. Si la partition EFI doit être écrite pendant le processus de démarrage, il se peut que ce pilote doive être intégré dans le micrologiciel. \n  • Pilote de support NvmExpressDxe-NVMe de MdeModulePkg. Ce pilote est inclus dans la plupart des micrologiciels de la génération Broadwell. Pour Haswell et les versions antérieures, si un disque SSD NVMe est installé, il est préférable de l'intégrer dans le micrologiciel. \n  • Le pilote de clavier USB UsbKbDxe ajoute la prise en charge du protocole AppleKeyMapAggregator basé sur l'implémentation du pilote de clavier USB personnalisé. Il s'agit d'une alternative au KeySupport intégré. \n  • VBoxHfs-possède un pilote qui prend en charge le système de fichiers HFS. Ce pilote peut remplacer le pilote HFSPlus à source fermée communément trouvé dans le micrologiciel Apple. Bien que pleinement fonctionnel, il est environ trois fois plus lent et n'a pas encore fait l'objet d'audits de sécurité. \n  • Le contrôleur USB XHCI dans XhciDxe-MdeModulePkg prend en charge les pilotes. Ce pilote est inclus dans la plupart des micrologiciels de la génération Sandy Bridge. Pour les anciens micrologiciels ou les anciens systèmes, il peut être utilisé pour prendre en charge les cartes PCI USB 3.0 externes \n  • Module d'interface graphique tiers OC standard NdkBootPicker";

/* Class = "NSTextFieldCell"; title = "MinVersion"; ObjectID = "7Ns-yB-e5j"; */
"7Ns-yB-e5j.title" = "MinVersion";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load embedded APFS drivers from APFS containers.\nAPFS EFI driver is bundled in all bootable APFS containers. This option performs loading of signed APFS drivers with respect to ScanPolicy. See more details in “EFI Jumpstart” section of Apple File System Reference."; ObjectID = "8Sc-F2-ONI"; */
"8Sc-F2-ONI.ibShadowedToolTip" = "Type: plist boolean \n Failsafe: false \n Description: charge les pilotes APFS intégrés à partir des conteneurs APFS. \n Le pilote EFS APFS est fourni dans tous les conteneurs APFS amorçables. Cette option effectue le chargement des pilotes APFS signés par rapport à ScanPolicy. Voir plus de détails dans la section «EFI Jumpstart» de la référence du système de fichiers Apple. ";

/* Class = "NSTabViewItem"; label = "ReservedMemory"; ObjectID = "8vC-O7-rpe"; */
"8vC-O7-rpe.label" = "ReservedMemory";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform UEFI controller connection after driver loading.\nThis option is useful for loading drivers following UEFI driver model, as they may not start by themselves. Examples of such drivers are filesystem or audio drivers. While effective, this option may not be necessary for drivers performing automatic connection, and may slightly slowdown the boot.\n\nNote: Some types of firmware, particularly those made by Apple, only connect the boot drive to speed up the boot process. Enable this option to be able to see all the boot options when running multiple drives."; ObjectID = "9f0-xd-rhT"; */
"9f0-xd-rhT.ibShadowedToolTip" = "Une fois le pilote chargé, effectuez la connexion du contrôleur UEFI. Cette option est utile pour charger des pilotes de système de fichiers, qui suivent généralement le modèle de pilote UEFI et peuvent ne pas démarrer d'eux-mêmes. Bien qu'efficace, cette option peut ne pas être nécessaire pour les pilotes qui effectuent des connexions automatiques et peut ralentir légèrement le démarrage.";

/* Class = "NSTextFieldCell"; title = "MinDate"; ObjectID = "9fO-yG-VWd"; */
"9fO-yG-VWd.title" = "MinDate";

/* Class = "NSButtonCell"; title = "FirmwareVolume"; ObjectID = "AW6-UR-4Ex"; */
"AW6-UR-4Ex.title" = "FirmwareVolume";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Codec address on the specified audio controller for audio support. Normally this contains first audio codec address on the builtin analog audio controller (HDEF). Audio codec addresses, e.g. 2, can be found in the debug log: \nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs) \nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative this value can be obtained from IOHDACodecDevice class in I/O Registry containing it in IOHDACodecAddress field."; ObjectID = "AZW-9D-hq6"; */
"AZW-9D-hq6.ibShadowedToolTip" = "Adresse du codec sur le contrôleur audio spécifié pour la prise en charge audio. Habituellement, il contient l'adresse du premier codec audio sur le contrôleur audio analogique intégré (HDEF). L'adresse du codec audio, telle que 2, se trouve dans le journal de débogage: \n OCAU: 1/3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<réduit>, 00000000) ( 4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<redaged>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redaged>, 02000000) (7 sorties) \n  \n  Alternativement, cette valeur peut être obtenue à partir de la classe IOHDACodecDevice dans le logiciel de registre d'E / S, qui est contenue dans le champ IOHDACodecAddress.";

/* Class = "NSButtonCell"; title = "AppleUserInterfaceTheme"; ObjectID = "BvY-5w-QBw"; */
"BvY-5w-QBw.title" = "AppleUserInterfaceTheme";

/* Class = "NSButtonCell"; title = "Scan/Browse"; ObjectID = "CLg-lY-N26"; */
"CLg-lY-N26.title" = "Parcourir";

/* Class = "NSButtonCell"; title = "IgnoreInvalidFlexRatio"; ObjectID = "CWI-LU-4dW"; */
"CWI-LU-4dW.title" = "IgnoreInvalidFlexRatio";

/* Class = "NSButtonCell"; title = "AppleSmcIo"; ObjectID = "Ddl-D0-484"; */
"Ddl-D0-484.title" = "AppleSmcIo";

/* Class = "NSMenuItem"; title = "UnusableMemory — EfiUnusableMemory"; ObjectID = "DwL-VG-qNh"; Note = "Do not localize"; */
"DwL-VG-qNh.title" = "UnusableMemory — EfiUnusableMemory";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Swap Command and Option keys during submission.\nThis option may be useful for keyboard layouts with Option key situated to the right of Command key."; ObjectID = "EIc-ff-Thn"; */
"EIc-ff-Thn.ibShadowedToolTip" = "Commutez les touches Commande et Option, sélectionnez généralement NON";

/* Class = "NSTextFieldCell"; title = "KeySupportMode"; ObjectID = "EeU-wj-caf"; */
"EeU-wj-caf.title" = "KeySupportMode";

/* Class = "NSButtonCell"; title = "PointerSupport"; ObjectID = "Elq-pL-QTD"; */
"Elq-pL-QTD.title" = "PointerSupport";

/* Class = "NSTextFieldCell"; title = "VolumeAmplifier"; ObjectID = "En7-ww-Uj5"; */
"En7-ww-Uj5.title" = "VolumeAmplifier";

/* Class = "NSTextFieldCell"; title = "KeyForgetThreshold"; ObjectID = "ErN-ks-EzO"; */
"ErN-ks-EzO.title" = "KeyForgetThreshold";

/* Class = "NSTabViewItem"; label = "APFS"; ObjectID = "F1Q-I5-6w7"; */
"F1Q-I5-6w7.label" = "APFS";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple SMC I/O protocol with a builtin version.\nThis protocol replaces legacy VirtualSmc UEFI driver, and is compatible with any SMC kernel extension. \nHowever, in case FakeSMC kernel extension is used, manual NVRAM key variable addition may be needed."; ObjectID = "FPA-9t-OzA"; */
"FPA-9t-OzA.ibShadowedToolTip" = "La dernière version intègre le protocole VirtualSmc.efi. \n Utilisez cette option pour supprimer le fichier VirtualSmc.efi dans le répertoire des pilotes. \n Cependant, si vous utilisez l'extension du noyau FakeSMC, vous devrez peut-être ajouter manuellement la variable de clé NVRAM.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Perform full device connection during APFS loading.\nInstead of partition handle connection normally used for APFS driver loading every handle is connected recursively.\nThis may take more time than usual but can be the only way to access APFS partitions on some  types of firmware such as those on older HP laptops."; ObjectID = "H5Y-DY-WOe"; */
"H5Y-DY-WOe.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Perform full device connection during APFS loading.\nInstead of partition handle connection normally used for APFS driver loading every handle is connected recursively.\nThis may take more time than usual but can be the only way to access APFS partitions on some firmwares like those found on older HP laptops.";

/* Class = "NSButtonCell"; title = "ReplaceTabWithSpace"; ObjectID = "HIh-Oc-UT7"; */
"HIh-Oc-UT7.title" = "ReplaceTabWithSpace";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging."; ObjectID = "HdB-KO-x50"; */
"HdB-KO-x50.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Hide verbose output from APFS driver.\nAPFS verbose output can be useful for debugging.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls Hash Services protocols with builtin versions. Should be set to true to ensure File Vault 2 compatibility on platforms providing broken SHA-1 hashing. Can be diagnosed by invalid cursor size with UIScale set to 02, in general platforms prior to APTIO V (Haswell and older) are affected."; ObjectID = "HpH-bP-96S"; */
"HpH-bP-96S.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Réparer le problème de taille de curseur de souris incorrecte lors de l'exécution de FileVault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Image Conversion protocol with a builtin version."; ObjectID = "ILy-av-YYi"; */
"ILy-av-YYi.ibShadowedToolTip" = "Reconstruisez l'icône de la pomme, sélectionnez généralement NON.";

/* Class = "NSTabViewItem"; label = "ProtocolOverrides"; ObjectID = "Ife-ug-MJ5"; */
"Ife-ug-MJ5.label" = "Substitutions de protocole";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Debug Log protocol with a builtin version."; ObjectID = "JLv-Tn-pJQ"; */
"JLv-Tn-pJQ.ibShadowedToolTip" = "Réinstallez le protocole Apple Debug Log avec une version intégrée.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls Data Hub protocol with a builtin version. This will delete all previous properties if the protocol was already installed."; ObjectID = "KN0-dq-pSV"; */
"KN0-dq-pSV.ibShadowedToolTip" = "Reconstruisez le datahub, sélectionnez NON ici.";

/* Class = "NSMenuItem"; title = "ACPIReclaimMemory — EfiACPIReclaimMemory"; ObjectID = "KsW-za-ip4"; Note = "Do not localize"; */
"KsW-za-ip4.title" = "ACPIReclaimMemory — EfiACPIReclaimMemory";

/* Class = "NSTextFieldCell"; title = "AudioCodec"; ObjectID = "L2f-gE-rBP"; */
"L2f-gE-rBP.title" = "AudioCodec";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver date.\nAPFS driver date connects APFS driver with the calendar release date. Older versions of APFS drivers may contain unpatched vulnerabilities, which can be used to inflict harm to the computer. This option permits restricting APFS drivers to only recent releases.\n• 0 — require the default supported release date of APFS in OpenCore. The default release date will increase with time and thus this setting is recommended. Currently set to 2020/01/01.\n• -1 — permit any release date to load (strongly discouraged).\n• Other — use custom minimal APFS release date, e.g. 20200401 for 2020/04/01. APFS release dates can be found in OpenCore boot log and OcApfsLib."; ObjectID = "L9i-6i-Mis"; */
"L9i-6i-Mis.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Date de pilote APFS minimale autorisée. \n La date de pilote APFS connecte le pilote APFS à la date de sortie du calendrier. Les versions plus anciennes des pilotes APFS peuvent contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de restreindre les pilotes APFS aux seules versions récentes. \n  • 0 - nécessite la date de sortie prise en charge par défaut d'APFS dans OpenCore. La date de sortie par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur 2020/01/01. \n  • -1 - autorise le chargement de toute date de sortie (fortement déconseillé). \n  • Autre - utilisez une date de sortie APFS minimale personnalisée, par exemple 20200401 pour 2020/04/01. Les dates de sortie d'APFS peuvent être trouvées dans le journal de démarrage d'OpenCore et OcApfsLib.";

/* Class = "NSButtonCell"; title = "OSInfo"; ObjectID = "Ljq-q2-IwF"; */
"Ljq-q2-IwF.title" = "OSInfo";

/* Class = "NSTableColumn"; headerCell.title = "Type"; ObjectID = "McE-CL-fQD"; */
"McE-CL-fQD.headerCell.title" = "Type";

/* Class = "NSButtonCell"; title = "DataHub"; ObjectID = "NGa-cY-Uzn"; */
"NGa-cY-Uzn.title" = "DataHub";

/* Class = "NSTextFieldCell"; title = "Resolution"; ObjectID = "NbU-Qi-Xhw"; */
"NbU-Qi-Xhw.title" = "Résolution de la console";

/* Class = "NSButtonCell"; title = "KeyFiltering"; ObjectID = "Of8-Ba-FhQ"; */
"Of8-Ba-FhQ.title" = "KeyFiltering";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal heard volume level from 0 to 100.\n\nScreen reader will use this volume level, when the calculated volume level is less than MinimumVolume. Boot chime sound will not play if the calculated volume level is less than MinimumVolume."; ObjectID = "PF5-bc-9Z2"; */
"PF5-bc-9Z2.ibShadowedToolTip" = "Le volume minimum est compris entre 0 et 100. \n  \n Lorsque le niveau de volume calculé est inférieur à MinimumVolume, le lecteur d'écran utilisera ce niveau de volume. Si le volume calculé est inférieur à MinimumVolume, aucune tonalité de démarrage ne retentira.";

/* Class = "NSButtonCell"; title = "AppleAudio"; ObjectID = "POq-ge-Ugg"; */
"POq-ge-Ugg.title" = "AppleAudio";

/* Class = "NSMenuItem"; title = "LoaderData — EfiLoaderData"; ObjectID = "PUI-Gl-EfE"; Note = "Do not localize"; */
"PUI-Gl-EfE.title" = "LoaderData — EfiLoaderData";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PVa-Cc-beC"; */
"PVa-Cc-beC.title" = "Quirks";

/* Class = "NSTextFieldCell"; title = "TextRenderer"; ObjectID = "QQF-qM-yZS"; */
"QQF-qM-yZS.title" = "TextRenderer(Rendu de texte)";

/* Class = "NSButtonCell"; title = "GlobalConnect"; ObjectID = "SDU-Ok-pEv"; */
"SDU-Ok-pEv.title" = "GlobalConnect";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Attempt to detach USB controller ownership from the firmware driver. While most types of firmware manage to do that properly, or at least have an option for this, some do not. As a result, the operating system may freeze upon boot. Not recommended unless required."; ObjectID = "TTJ-UT-Xng"; */
"TTJ-UT-Xng.ibShadowedToolTip" = "La plupart des cartes mères ont pour fonction de libérer automatiquement la propriété USB. Nous choisissons NON. Si votre clavier et votre souris sont bloqués ou que la clé USB échoue, essayez de choisir Oui.";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Set internal keyboard input translation to AppleKeyMapAggregator protocol mode.\n• Auto — Performs automatic choice as available with the following preference: AMI, V2, V1.\n• V1 — Uses UEFI standard legacy input protocol EFI_SIMPLE_TEXT_INPUT_PROTOCOL.\n• V2 — Uses UEFI standard modern input protocol EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.\n• AMI — Uses APTIO input protocol AMI_EFIKEYCODE_PROTOCOL.\n\nNote: Currently V1, V2, and AMI unlike Auto only do filtering of the particular specified protocol. This may change in the future versions."; ObjectID = "TTL-Rn-Avg"; */
"TTL-Rn-Avg.ibShadowedToolTip" = "Auto: mode de protocole de conversion de valeurs-clés \n V1: protocole d'entrée hérité UEFI \n V2: nouveau protocole d'entrée UEFI \n AMI: protocole d'entrée APTIO";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Minimal allowed APFS driver version.\nAPFS driver version connects APFS driver with the macOS release. APFS drivers from older macOS releases will become unsupported and thus may contain unpatched vulnerabilities, which can be used to inflict harm to the computer. This option permits restricting APFS drivers to only modern macOS versions.\n• 0 — require the default supported version of APFS in OpenCore. The default version will increase with time and thus this setting is recommended. Currently set to the latest point release from High Sierra.\n• -1 — permit any version to load (strongly discouraged).\n• Other — use custom minimal APFS version, e.g. 1412101001000000 from macOS Catalina 10.15.4. APFS versions can be found in OpenCore boot log and OcApfsLib."; ObjectID = "TYZ-jG-lfr"; */
"TYZ-jG-lfr.ibShadowedToolTip" = "Type: entier plist \n Failsafe: 0 \n Description: Version minimale autorisée du pilote APFS. \n La version du pilote APFS connecte le pilote APFS à la version macOS. Les pilotes APFS des anciennes versions de macOS ne seront plus pris en charge et peuvent donc contenir des vulnérabilités non corrigées, qui peuvent être utilisées pour endommager votre ordinateur. Cette option permet de limiter les pilotes APFS aux seules versions modernes de macOS. \n  • 0 - nécessite la version prise en charge par défaut d'APFS dans OpenCore. La version par défaut augmentera avec le temps et ce paramètre est donc recommandé. Actuellement défini sur la dernière version ponctuelle de High Sierra. \n  • -1 - autorise le chargement de toute version (fortement déconseillé). \n  • Autre - utilisez une version APFS minimale personnalisée, par exemple 1412101001000000 de macOS Catalina 10.15.4. Les versions APFS peuvent être trouvées dans le journal de démarrage OpenCore et OcApfsLib.";

/* Class = "NSButtonCell"; title = "ReleaseUsbOwnership"; ObjectID = "UMT-DK-9B5"; */
"UMT-DK-9B5.title" = "ReleaseUsbOwnership";

/* Class = "NSMenuItem"; title = "BootServiceCode — EfiBootServicesCode"; ObjectID = "UNS-wv-SeD"; Note = "Do not localize"; */
"UNS-wv-SeD.title" = "BootServiceCode — EfiBootServicesCode";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls device property protocol with a builtin version. This will delete all previous properties if it was already installed. This may be used to ensure full compatibility on VMs or legacy Macs."; ObjectID = "Ueb-hn-jBT"; */
"Ueb-hn-jBT.ibShadowedToolTip" = "Sélectionnez généralement NO \n  pour garantir une compatibilité totale sur la machine virtuelle ou la vieille pomme blanche.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Index of the output port of the specified codec starting from 0.\nNormally this contains the index of the green out of the builtin analog audio controller (HDEF). The number of output nodes (N) in the debug log (marked in bold):\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs) \n\nThe quickest way to find the right port is to bruteforce the values from 0 to N - 1."; ObjectID = "UrW-oc-0Oc"; */
"UrW-oc-0Oc.ibShadowedToolTip" = "Spécifiez l'index du port de sortie du codec, généralement à partir de 0. \n  \n Le moyen le plus rapide pour trouver le port correct est de forcer la valeur de 0 à N-1. N est le nombre d'index de port de sortie affichés dans le journal, tels que Il y a 3 sorties dans le journal, vous pouvez les essayer de 0 à 2.";

/* Class = "NSTabViewItem"; label = "Drivers"; ObjectID = "V9Z-z9-Ejd"; */
"V9Z-z9-Ejd.label" = "Pilote UEFI";

/* Class = "NSMenuItem"; title = "MemoryMappedIO — EfiMemoryMappedIO"; ObjectID = "XBh-jM-PDL"; Note = "Do not localize"; */
"XBh-jM-PDL.title" = "MemoryMappedIO — EfiMemoryMappedIO";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple IMG4 Verification protocol with a builtin version. This protocol is used to verify im4m manifest files used by Apple Secure Boot."; ObjectID = "XQL-ML-llQ"; */
"XQL-ML-llQ.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple IMG4 Verification protocol with a builtin version. This protocol is used to verify im4m manifest files used by Apple Secure Boot.";

/* Class = "NSButtonCell"; title = "AppleRtcRam"; ObjectID = "Xjp-N3-zFD"; */
"Xjp-N3-zFD.title" = "AppleRtcRam";

/* Class = "NSButtonCell"; title = "UnblockFsConnect"; ObjectID = "YFj-X6-x1j"; */
"YFj-X6-x1j.title" = "UnblockFsConnect";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist string\nFailsafe: empty string\nDescription: Device path of the specified audio controller for audio support.\nNormally this contains builtin analog audio controller (HDEF) device path, e.g. PciRoot(0x0)/Pci(0x1b,0x0).\nThe list of recognised audio controllers can be found in the debug log:\nOCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(<redacted>,00000000) (4 outputs)\nOCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(<redacted>,00000000) (1 outputs)\nOCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(<redacted>,02000000) (7 outputs)\n\nAs an alternative gfxutil -f HDEF command can be used in macOS. Specifying empty device path will result in the first available audio controller to be used."; ObjectID = "YTE-Ba-80O"; */
"YTE-Ba-80O.ibShadowedToolTip" = "Chemin du périphérique pour le contrôleur audio spécifié pour la prise en charge des fonctionnalités audio. \n Habituellement, il contient le chemin de périphérique du contrôleur audio analogique (HDEF) intégré, tel que: PciRoot (0x0) / Pci (0x1b, 0x0). \n Une liste de contrôleurs audio se trouve dans le journal de débogage: \n OCAU: 1 / 3 PciRoot (0x0) / Pci (0x1,0x0) / Pci (0x0,0x1) / VenMsg (<expurgé>, 00000000) (4 sorties) \n OCAU: 2/3 PciRoot (0x0) / Pci (0x3,0x0) / VenMsg (<réduit>, 00000000) (1 sorties) \n OCAU: 3/3 PciRoot (0x0) / Pci (0x1B, 0x0) / VenMsg (<redigned>, 02000000) (7 sorties) \n  \n Également disponible sur Sous macOS, utilisez la commande gfxutil -f HDEF pour obtenir ou afficher l'adresse du périphérique audio à l'aide de l'outil Hackintool. Si vous spécifiez un chemin de périphérique vide, le premier contrôleur audio disponible sera utilisé.";

/* Class = "NSButtonCell"; title = "Download/Update drivers"; ObjectID = "YW9-8V-SGH"; */
"YW9-8V-SGH.title" = "Download/Update drivers";

/* Class = "NSButtonCell"; title = "UnicodeCollation"; ObjectID = "ZCa-Hx-UFl"; */
"ZCa-Hx-UFl.title" = "UnicodeCollation";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Use builtin graphics output protocol renderer for console.\n\nOn some types of firmware, such as on the MacPro5,1, this may provide better performance or fix rendering issues. However, this option is not recommended unless there is an obvious benefit as it may result in issues such as slower scrolling."; ObjectID = "a3V-hG-HCC"; */
"a3V-hG-HCC.ibShadowedToolTip" = "Utilisez le rendu du protocole de sortie graphique intégré comme console. \n Sur certains micrologiciels, cela peut offrir de meilleures performances et même résoudre les problèmes de rendu, mais il est généralement recommandé de ne pas utiliser cette option, sauf en cas d'avantage évident.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Event protocol with a builtin version. This may be used to ensure File Vault 2 compatibility on VMs or legacy Macs."; ObjectID = "aUv-Bv-xUd"; */
"aUv-Bv-xUd.ibShadowedToolTip" = "Requis pour les machines virtuelles avec des macs de coffre-fort. Sélectionnez NON.";

/* Class = "NSTextFieldCell"; title = "PointerSupportMode"; ObjectID = "anR-lZ-CjV"; */
"anR-lZ-CjV.title" = "PointerSupportMode";

/* Class = "NSMenuItem"; title = "LoaderCode — EfiLoaderCode"; ObjectID = "b7Y-CD-r7l"; Note = "Do not localize"; */
"b7Y-CD-r7l.title" = "LoaderCode — EfiLoaderCode";

/* Class = "NSButtonCell"; title = "ProvideConsoleGop"; ObjectID = "bdr-Pu-Crr"; */
"bdr-Pu-Crr.title" = "ProvideConsoleGop";

/* Class = "NSMenuItem"; title = "RuntimeData — EfiRuntimeServicesData"; ObjectID = "c5S-aW-uXu"; Note = "Do not localize"; */
"c5S-aW-uXu.title" = "RuntimeData — EfiRuntimeServicesData";

/* Class = "NSButtonCell"; title = "KeySupport"; ObjectID = "cia-MM-Epa"; */
"cia-MM-Epa.title" = "KeySupport";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware do not print tab characters or everything that follows them, causing difficulties in using the UEFI Shell’s builtin text editor to edit property lists and other documents. This option makes the console output spaces instead of tabs.\n\nNote: This option only applies to System renderer."; ObjectID = "dDZ-Zb-RKY"; */
"dDZ-Zb-RKY.ibShadowedToolTip" = "Certains firmwares ne peuvent pas imprimer les onglets, ni même tout ce qui se trouve après les onglets, ce qui rend difficile, voire impossible, l'utilisation de l'éditeur de texte intégré au shell UEFI pour modifier les listes de propriétés et autres documents. Cette option entraîne le remplacement des onglets par l'espace de sortie de la console. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButtonCell"; title = "SanitiseClearScreen"; ObjectID = "dXN-AE-igp"; */
"dXN-AE-igp.title" = "SanitiseClearScreen";

/* Class = "NSButtonCell"; title = "AppleBootPolicy"; ObjectID = "ddJ-by-qVm"; */
"ddJ-by-qVm.title" = "AppleBootPolicy";

/* Class = "NSButtonCell"; title = "AppleKeyMap"; ObjectID = "dpz-CS-4eq"; */
"dpz-CS-4eq.title" = "AppleKeyMap";

/* Class = "NSTextFieldCell"; title = "KeyMergeThreshold"; ObjectID = "du6-Wl-DOI"; */
"du6-Wl-DOI.title" = "KeyMergeThreshold";

/* Class = "NSMenuItem"; title = "PalCode — EfiPalCode"; ObjectID = "dzI-am-EZX"; Note = "Do not localize"; */
"dzI-am-EZX.title" = "PalCode — EfiPalCode";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable internal pointer driver.\nThis option implements standard UEFI pointer protocol (EFI_SIMPLE_POINTER_PROTOCOL) through select OEM protocols. The option may be useful on Z87 ASUS boards, where EFI_SIMPLE_POINTER_PROTOCOL is broken."; ObjectID = "dzp-p6-AHb"; */
"dzp-p6-AHb.ibShadowedToolTip" = "Si vous êtes un ASUS z87 ou z97, vous devez activer l'option PointerSupport.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Ensure GOP (Graphics Output Protocol) on console handle.\nmacOS bootloader requires GOP or UGA (for 10.4 EfiBoot) to be present on console handle, yet the exact location of  the graphics protocol is not covered by the UEFI specification. This option will ensure GOP and UGA, if present, are available on the console handle.\n\nNote: This option will also replace broken GOP protocol on console handle, which may be the case on MacPro5,1 with newer GPUs."; ObjectID = "eGd-xS-rQf"; */
"eGd-xS-rQf.ibShadowedToolTip" = "Avant de sélectionner l'écran système, vous pouvez voir des informations sur votre erreur de configuration de configuration. Vous pouvez ajuster votre configuration en fonction de ces informations, ou vous pouvez choisir OUI pour ignorer. Il est recommandé de choisir OUI.";

/* Class = "NSMenuItem"; title = "Persistent — EfiPersistentMemory"; ObjectID = "eMM-3b-cBd"; Note = "Do not localize"; */
"eMM-3b-cBd.title" = "Persistent — EfiPersistentMemory";

/* Class = "NSMenuItem"; title = "MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace"; ObjectID = "eQX-uX-ZBd"; Note = "Do not localize"; */
"eQX-uX-ZBd.title" = "MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace";

/* Class = "NSButtonCell"; title = "HideVerbose"; ObjectID = "egr-8J-RIS"; */
"egr-8J-RIS.title" = "HideVerbose";

/* Class = "NSTextFieldCell"; title = "MinimumVolume"; ObjectID = "ehu-K3-gbY"; */
"ehu-K3-gbY.title" = "MinimumVolume";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide UGA protocol instances on top of GOP protocol.\n\nSome types of firmware do not implement the legacy UGA protocol but this may be required for screen output by older EFI applications such as EfiBoot from 10.4."; ObjectID = "ejz-UL-xuF"; */
"ejz-UL-xuF.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Provide UGA protocol instances on top of GOP protocol.\n\nSome types of firmware do not implement the legacy UGA protocol but this may be required for screen output by older EFI applications such as EfiBoot from 10.4.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Remove duplicate entries BootOrder variable in EFI_GLOBAL_VARIABLE_GUID.\n\nThis quirk requires RequestBootVarRouting to be enabled and therefore OC_FIRMWARE_RUNTIME protocol imple- mented in OpenRuntime.efi.\nBy redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals:\n• Operating systems are jailed and only controlled by OpenCore boot environment to enhance security.\n• Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation\nwakes for cases that require reboots with OpenCore in the middle.\n• Potentially incompatible boot entries, such as macOS entries, are not deleted or anyhow corrupted.\n\nHowever, some types of firmware do their own boot option scanning on startup by checking for file presence on the available disks. This scanning often includes non-standard locations such as Windows Bootloader paths. This is typically not an issue but some firmware, such as ASUS firmware on the APTIO V, have bugs. On such, scanning is implemented improperly and firmware preferences may get accidentally corrupted due to BootOrder entry duplication (each option will be added twice) making it impossible to boot without resetting NVRAM.\n\nTo trigger the bug one, some valid boot options (e.g. OpenCore) are required. Then install Windows with RequestBootVarRouting enabled. As the Windows bootloader option will not be created by the Windows installer, the firmware will attempt to create this itself, leading to a corruption of its boot option list.\n\nThis quirk removes all duplicates in BootOrder variable attempting to resolve the consequences of the bugs upon OpenCore loading. It is recommended to use this key along with BootProtect option."; ObjectID = "esT-oy-xWe"; */
"esT-oy-xWe.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Remove duplicate entries BootOrder variable in EFI_GLOBAL_VARIABLE_GUID.\n\nThis quirk requires RequestBootVarRouting to be enabled and therefore OC_FIRMWARE_RUNTIME protocol imple- mented in OpenRuntime.efi.\nBy redirecting Boot prefixed variables to a separate GUID namespace with the help of RequestBootVarRouting quirk we achieve multiple goals:\n• Operating systems are jailed and only controlled by OpenCore boot environment to enhance security.\n• Operating systems do not mess with OpenCore boot priority, and guarantee fluent updates and hibernation\nwakes for cases that require reboots with OpenCore in the middle.\n• Potentially incompatible boot entries, such as macOS entries, are not deleted or anyhow corrupted.\n\nHowever, some types of firmware do their own boot option scanning on startup by checking for file presence on the available disks. This scanning often includes non-standard locations such as Windows Bootloader paths. This is typically not an issue but some firmware, such as ASUS firmware on the APTIO V, have bugs. On such, scanning is implemented improperly and firmware preferences may get accidentally corrupted due to BootOrder entry duplication (each option will be added twice) making it impossible to boot without resetting NVRAM.\n\nTo trigger the bug one, some valid boot options (e.g. OpenCore) are required. Then install Windows with RequestBootVarRouting enabled. As the Windows bootloader option will not be created by the Windows installer, the firmware will attempt to create this itself, leading to a corruption of its boot option list.\n\nThis quirk removes all duplicates in BootOrder variable attempting to resolve the consequences of the bugs upon OpenCore loading. It is recommended to use this key along with BootProtect option.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware reset screen resolutions to a failsafe value (such as 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to System renderer. On all known affected systems ConsoleMode had to be set to empty string for this to work."; ObjectID = "f0k-6s-W9I"; */
"f0k-6s-W9I.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware reset screen resolutions to a failsafe value (such as 1024x768) on the attempts to clear screen contents when large display (e.g. 2K or 4K) is used. This option attempts to apply a workaround.\n\nNote: This option only applies to System renderer. On all known affected systems ConsoleMode had to be set to empty string for this to work.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\nThis option allows to update firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value generally improves performance and responsiveness of the interface and input handling.\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. In case of issues, this option can be left as 0."; ObjectID = "fda-QM-Vl4"; */
"fda-QM-Vl4.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Set architecture timer resolution.\nThis option allows to update firmware architecture timer period with the specified value in 100 nanosecond units. Setting a lower value generally improves performance and responsiveness of the interface and input handling.\nThe recommended value is 50000 (5 milliseconds) or slightly higher. Select ASUS Z87 boards use 60000 for the interface. Apple boards use 100000. In case of issues, this option can be left as 0.";

/* Class = "NSButtonCell"; title = "AppleSecureBoot"; ObjectID = "gC4-eW-BlL"; */
"gC4-eW-BlL.title" = "AppleSecureBoot";

/* Class = "NSTabViewItem"; label = "Output"; ObjectID = "gJG-UT-7D3"; */
"gJG-UT-7D3.label" = "Afficher la sortie liée";

/* Class = "NSButtonCell"; title = "KeySwap"; ObjectID = "h6b-rN-daY"; */
"h6b-rN-daY.title" = "KeySwap";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string\nFailsafe: Empty string\nDescription: Sets console output screen resolution.\n• Set to WxH@Bpp (e.g. 1920x1080@32) or WxH (e.g. 1920x1080) formatted string to request custom resolution from GOP if available.\n• Set to empty string not to change screen resolution.\n• Set to Max to try to use largest available screen resolution.\nOn HiDPI screens APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM variable may need to be set to 02 to enable HiDPI scaling in FileVault 2 UEFI password interface and boot screen logo. Refer to Recommended Variables section for more details.\nNote: This will fail when console handle has no GOP protocol. When the firmware does not provide it, it can be added with ProvideConsoleGop set to true."; ObjectID = "hVw-xH-z40"; Note = "Do Not Translate"; */
"hVw-xH-z40.ibShadowedToolTip" = "Définir la résolution d'écran de sortie de la console. \n  • Définir sur vide pour ne pas modifier la résolution d'écran. \n  • Définir sur Max pour essayer d'utiliser la plus grande résolution d'écran disponible. \n Remarque: si le descripteur de la console ne possède pas de protocole GOP, cela échouera. Vous pouvez définir la valeur True de ProviderConsoleGop pour l'ajouter.";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Start address of the reserved memory region, which should be allocated as reserved effectively marking the memory of this type inaccessible to the operating system.\n\nThe addresses written here must be part of the memory map, have EfiConventionalMemory type, and page-aligned (4 KBs).\n\nNote: Some types of firmware may not allocate memory areas used by S3 (sleep) and S4 (hibernation) code unless CSM is enabled causing wake failures. After comparing the memory maps with CSM disabled and enabled you could find these areas in the lower memory and fix them up by doing the reservation. See Sample.plist for more details.\n\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Size\nType: plist integer\nFailsafe: 0\nDescription: Size of the reserved memory region, must be page-aligned (4 KBs).\n4. Type\nType: plist string\nFailsafe: Reserved\nDescription: Memory region type matching the UEFI specification memory descriptor types. Mapping:\n• Reserved — EfiReservedMemoryType\n• LoaderCode — EfiLoaderCode\n• LoaderData — EfiLoaderData\n• BootServiceCode — EfiBootServicesCode\n• BootServiceData — EfiBootServicesData\n• RuntimeCode — EfiRuntimeServicesCode\n• RuntimeData — EfiRuntimeServicesData\n• Available — EfiConventionalMemory\n• Persistent — EfiPersistentMemory\n• UnusableMemory — EfiUnusableMemory\n• ACPIReclaimMemory — EfiACPIReclaimMemory\n• ACPIMemoryNVS — EfiACPIMemoryNVS\n• MemoryMappedIO — EfiMemoryMappedIO\n• MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace\n• PalCode — EfiPalCode\n5. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This region will not be reserved unless set to true."; ObjectID = "hs4-gm-1Ct"; */
"hs4-gm-1Ct.ibShadowedToolTip" = "1. Adresse \nType: entier plist \nFailsafe: 0 \nDescription: Adresse de début de la région de mémoire réservée, qui doit être allouée comme réservée, ce qui marque efficacement la mémoire de ce type inaccessible au système d'exploitation. \nLes adresses écrites ici doivent faire partie de la carte mémoire, ont le type EfiConventionalMemory et sont alignés sur la page (4 Ko). \n2. Commentaire \nType: chaîne de plist \nFailsafe: chaîne vide \nDescription: chaîne ASCII arbitraire utilisée pour fournir une référence lisible par l'homme pour l'entrée. Il est défini par l'implémentation si cette valeur est utilisée. \n3. Taille \nType: entier plist \nFailsafe: 0 \nDescription: La taille de la zone de mémoire réservée doit être alignée sur la page (4 Ko). \n4. Activé \nType: plist boolean \nFailsafe: false \nDescription: Cette région ne sera pas réservée sauf si elle est définie sur true.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple User Interface Theme protocol with a builtin version."; ObjectID = "iFT-xW-ZaT"; */
"iFT-xW-ZaT.ibShadowedToolTip" = "Réinstallez le protocole de thème de l'interface utilisateur Apple à l'aide de la version intégrée.";

/* Class = "NSTextFieldCell"; title = "TscSyncTimeout"; ObjectID = "ifT-4Q-EvN"; */
"ifT-4Q-EvN.title" = "TscSyncTimeout";

/* Class = "NSButtonCell"; title = "AppleFramebufferInfo"; ObjectID = "ixW-rs-w20"; */
"ixW-rs-w20.title" = "AppleFramebufferInfo";

/* Class = "NSView"; ibShadowedToolTip = "Type: plist array \nDescription: Designed to be filled with plist dict values, describing memory areas exquisite to particular firmware and hardware functioning, which should not be used by the operating system. An example of such\nmemory region could be second 256 MB corrupted by Intel HD 3000 or an area with faulty RAM. See Reserved-Memory Properties section below."; ObjectID = "k2W-U9-Ysu"; */
"k2W-U9-Ysu.ibShadowedToolTip" = "Type: tableau plist \nDescription: Conçu pour être rempli avec des valeurs dict plist, décrivant les zones de mémoire exquises pour un fonctionnement particulier du firmware et du matériel, qui ne doivent pas être utilisées par le système d'exploitation. Un exemple d'une telle région \nmemory pourrait être un second 256 Mo corrompu par Intel HD 3000 ou une zone avec une RAM défectueuse. Voir la section Propriétés de la mémoire réservée ci-dessous.";

/* Class = "NSButtonCell"; title = "AppleEvent"; ObjectID = "k4I-Ol-kq5"; */
"k4I-Ol-kq5.title" = "AppleEvent";

/* Class = "NSTextFieldCell"; title = "Console Mode"; ObjectID = "k5b-42-EPT"; */
"k5b-42-EPT.title" = "Console Mode";

/* Class = "NSButtonCell"; title = "Connect Drivers"; ObjectID = "kBk-75-acl"; */
"kBk-75-acl.title" = "Pilote de connexion";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Assume simultaneous combination for keys submitted within this timeout in milliseconds.\nSimilarly to KeyForgetThreshold, this option works around the sequential nature of key submission. To be able to recognise simultaneously pressed keys in the situation when all keys arrive sequentially, we are required to set a timeout within which we assume the keys were pressed together.\nHolding multiple keys results in reports every 2 and 1 milliseconds for VMware and APTIO V respectively. Pressing keys one after the other results in delays of at least 6 and 10 milliseconds for the same platforms. The recommended value for this option is 2 milliseconds, but it may be decreased for faster platforms and increased for slower."; ObjectID = "kKb-0m-i9e"; */
"kKb-0m-i9e.ibShadowedToolTip" = "Intervalle de temps (unité: millisecondes) auquel la clé est réinitialisée en appuyant sur la touche. Similaire à KeyForgetThreshold, cette option s'applique à la nature séquentielle de la soumission de la clé. Afin de pouvoir reconnaître les touches enfoncées simultanément lorsque toutes les touches arrivent dans l'ordre, nous devons définir un délai d'expiration pendant lequel nous supposons que les touches sont enfoncées simultanément. \n Le maintien de plusieurs clés signalera respectivement VMware et APTIOV toutes les 2 ms et 1 ms. Pour la même plateforme, le fait d'appuyer les touches l'une après l'autre provoque un retard d'au moins 6 à 10 millisecondes. La valeur recommandée pour cette option est de 2 millisecondes, mais elle peut diminuer pour les plates-formes plus rapides et augmenter pour les plates-formes plus lentes.";

/* Class = "NSTextFieldCell"; title = "AudioOut"; ObjectID = "kM6-tO-pns"; */
"kM6-tO-pns.title" = "AudioOut";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Load APFS drivers for newly connected devices.\nPerforms APFS driver loading not only at OpenCore startup but also during boot picker. This permits APFS USB hot plug. Disable if not required."; ObjectID = "kSG-eA-B2o"; */
"kSG-eA-B2o.ibShadowedToolTip" = "Type: plist boolean\n Failsafe: false\nDescription: Load APFS drivers for newly connected devices.\nPerforms APFS driver loading not only at OpenCore startup but also during boot picker. This permits APFS USB hot plug. Disable if not required.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly reinstalls OS Info protocol with builtin versions. This protocol is generally used to receive notifications from macOS bootloader, by the firmware or by other applications."; ObjectID = "l9b-pk-oii"; */
"l9b-pk-oii.ibShadowedToolTip" = "Forcer la réinstallation du protocole OS Info à l'aide de la version intégrée. Ce protocole est généralement utilisé pour recevoir des notifications du chargeur de démarrage macOS, du micrologiciel ou d'autres applications \n Temporairement inutile, sélectionnez NON.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple Framebuffer Info protocol with a builtin version. This may be used to override framebuffer information on VMs or legacy Macs to improve compatibility with legacy EfiBoot such as the one in macOS 10.4."; ObjectID = "lAy-Dr-HPx"; */
"lAy-Dr-HPx.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple Framebuffer Info protocol with a builtin version. This may be used to override framebuffer information on VMs or legacy Macs to improve compatibility with legacy EfiBoot like the one in macOS 10.4.";

/* Class = "NSTableColumn"; headerCell.title = "Address"; ObjectID = "ldi-uY-9wO"; */
"ldi-uY-9wO.headerCell.title" = "Adresse";

/* Class = "NSComboBox"; ibShadowedToolTip = "Type: plist string \nFailsafe: Empty string \nDescription: Sets console output mode as specified with the WxH (e.g. 80x24) formatted string.\nSet to empty string not to change console mode. Set to Max to try to use largest available console mode. Currently Builtin text renderer supports only one console mode, so this option is ignored.\n\nNote: This field is best left empty on most type of firmware."; ObjectID = "lye-vu-fi3"; Note = "Do Not Translate"; */
"lye-vu-fi3.ibShadowedToolTip" = "La définition d'une chaîne vide ne modifie pas le mode de la console. Définissez sur Max pour essayer d'utiliser le plus grand mode de console disponible. \n Dans la plupart des cas, laissez-le vide!";

/* Class = "NSPopUpButton"; ibShadowedToolTip = "Type: plist string\nFailsafe: BuiltinGraphics\nDescription: Chooses renderer for text going through standard console output.\nCurrently two renderers are supported: Builtin and System. System renderer uses firmware services for text rendering. Builtin bypassing firmware services and performs text rendering on its own. Different renderers support a different set of options. It is recommended to use Builtin renderer, as it supports HiDPI mode and uses full screen resolution.\nUEFI firmware generally supports ConsoleControl with two rendering modes: Graphics and Text. Some types of firmware do not support ConsoleControl and rendering modes. OpenCore and macOS expect text to only be shown in Graphics mode and graphics to be drawn in any mode. Since this is not required by UEFI specification, exact behaviour varies.\nValid values are combinations of text renderer and rendering mode:\n• BuiltinGraphics — Switch to Graphics mode and use Builtin renderer with custom ConsoleControl.\n• BuiltinText — Switch to Text mode and use Builtin renderer with custom ConsoleControl.\n• SystemGraphics — Switch to Graphics mode and use System renderer with custom ConsoleControl.\n• SystemText — Switch to Text mode and use System renderer with custom ConsoleControl.\n• SystemGeneric — Use System renderer with system ConsoleControl assuming it behaves correctly.\n\nThe use of BuiltinGraphics is generally straightforward. For most platforms it is necessary to enable ProvideConsoleGop, set Resolution to Max. BuiltinText variant is an alternative BuiltinGraphics for some very old and buggy laptop firmware, which can only draw in Text mode.\n\nThe use of System protocols is more complicated. In general the preferred setting is SystemGraphics or SystemText. Enabling ProvideConsoleGop, setting Resolution to Max, enabling ReplaceTabWithSpace is useful on almost all platforms. SanitiseClearScreen, IgnoreTextInGraphics, and ClearScreenOnModeSwitch are more specific, and their use depends on the firmware.\n\nNote: Some Macs, namely MacPro5,1, may have broken console output with newer GPUs, and thus only BuiltinGraphics may work for them."; ObjectID = "mlh-hW-OqT"; */
"mlh-hW-OqT.ibShadowedToolTip" = "Sélectionnez un rendu pour la sortie de texte via la console standard. \n Deux rendus sont actuellement pris en charge: intégré et système. Le rendu système utilise des services de micrologiciel pour le rendu de texte. La fonction intégrée contourne le service de micrologiciel et effectue le rendu de texte de son propre chef. Différents moteurs de rendu prennent en charge différents ensembles d'options. Il est recommandé d'utiliser le moteur de rendu intégré car il prend en charge le mode HiDPI et utilise une résolution plein écran. \n Le contenu de l'option est une combinaison de rendu de texte et de mode de rendu: \n  • BuiltinGraphics - passez en mode \"graphiques\" et utilisez le rendu intégré avec un ConsoleControl personnalisé. \n  • SystemGraphics-passez en mode \"graphiques\", puis Utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemText - basculez en mode texte et utilisez le rendu système avec un ConsoleControl personnalisé. \n  • SystemGeneric - utilisez le rendu système avec le système ConsoleControl et supposez que son comportement est correct. \n BuiltinGraphics est généralement simple à utiliser. Pour la plupart des plates-formes, ProviderConsoleGop doit être activé, définir l'option de résolution sur Max et choisir de configurer Scale. \n L'utilisation des protocoles système est plus compliquée. Habituellement, le paramètre préféré est SystemGraphics ou SystemText. L'activation de ProviderConsoleGop, la définition de «Résolution» sur «Max» et l'activation de «ReplaceTabWithSpace» sont utiles sur presque toutes les plateformes. SanitiseClearScreen, IgnoreTextInGraphics et ClearScreenOnModeSwitch sont plus spécifiques et leur utilisation dépend du firmware. \n  \n Remarque: Certains modèles de Mac, tels que MacPro5,1, peuvent avoir une sortie de console corrompue sur des GPU plus récents, donc seuls BuiltinGraphics fonctionnera pour eux.";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "n2P-We-NTM"; */
"n2P-We-NTM.headerCell.title" = "Activée";

/* Class = "NSButtonCell"; title = "DirectGopRendering"; ObjectID = "nIf-jD-bYP"; */
"nIf-jD-bYP.title" = "DirectGopRendering";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forcibly wraps Firmware Volume protocols or installs new to support custom cursor images for File Vault 2. Should be set to true to ensure File Vault 2 compatibility on everything but VMs and legacy Macs.\n\nNote: Several virtual machines including VMware may have corrupted cursor image in HiDPI mode and thus may also require this setting to be enabled."; ObjectID = "nvr-JF-3ne"; */
"nvr-JF-3ne.ibShadowedToolTip" = "Sélectionnez généralement NON. \n Fixer les problèmes d'interface utilisateur avec Filevault, défini sur OUI pour une meilleure compatibilité avec FileVault";

/* Class = "NSMenuItem"; title = "Available — EfiConventionalMemory"; ObjectID = "nyc-OA-Vfg"; Note = "Do not localize"; */
"nyc-OA-Vfg.title" = "Available — EfiConventionalMemory";

/* Class = "NSButtonCell"; title = "DeviceProperties"; ObjectID = "oMi-yN-r8X"; */
"oMi-yN-r8X.title" = "DeviceProperties";

/* Class = "NSButtonCell"; title = "AudioSupport"; ObjectID = "oT1-Q2-rhc"; */
"oT1-Q2-rhc.title" = "AudioSupport";

/* Class = "NSMenuItem"; title = "BootServiceData — EfiBootServicesData"; ObjectID = "q2q-z0-cAo"; Note = "Do not localize"; */
"q2q-z0-cAo.title" = "BootServiceData — EfiBootServicesData";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware only clear part of the screen when switching from graphics to text mode, leaving a fragment of previously drawn images visible. This option fills the entire graphics screen with black colour before switching to text mode.\n\nNote: This option only applies to System renderer."; ObjectID = "qMh-AF-g0P"; */
"qMh-AF-g0P.ibShadowedToolTip" = "Lorsque le mode graphique passe en mode texte, certains micrologiciels n'effacent qu'une partie de l'écran, rendant visibles les fragments d'image précédemment dessinés. Cette option remplit tout l'écran graphique de noir avant de passer en mode texte. \n Remarque: cette option fonctionne uniquement avec le rendu système.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Forces Resolution to be set in cases where the desired resolution is not available by default, such \nas on legacy Intel GMA and first generation Intel HD Graphics (Ironlake/Arrandale). Setting Resolution to Max will try to pull the largest available resolution from the connected display’s EDID."; ObjectID = "qSg-5G-J1y"; */
"qSg-5G-J1y.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Forces Resolution to be set in cases where the desired resolution is not available by default, such \nas on legacy Intel GMA and first generation Intel HD Graphics (Ironlake/Arrandale). Setting Resolution to Max will try to pull the largest available resolution from the connected display’s EDID.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to select RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array."; ObjectID = "r1b-ma-oOs"; */
"r1b-ma-oOs.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false \nDescription: Reinstalls Apple RTC RAM protocol with builtin version.\n\nNote: Builtin version of Apple RTC RAM protocol may filter out I/O attempts to select RTC memory addresses. \nThe list of addresses can be specified in 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist variable as a data array.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nDefault value: false\nDescription: Reinstalls apple boot policy protocol with a builtin version. This may be used to ensure APFS compatibility on VMs or legacy Macs.\n\nNote: Some Macs, namely MacPro5,1, do have APFS compatibility, but their Apple Boot Policy protocol contains recovery detection issues, thus using this option is advised on them as well."; ObjectID = "rMl-Kr-h3I"; */
"rMl-Kr-h3I.ibShadowedToolTip" = "Il est utilisé pour assurer la compatibilité APFS sur les machines virtuelles ou les vieilles pommes blanches. En règle générale, sélectionnez NON.";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Multiplication coefficient for system volume to raw volume linear translation from 0 to 1000.\nVolume level range read from SystemAudioVolume varies depending on the codec. To transform read value in [0, 127] range into raw volume range [0, 100] the read value is scaled to VolumeAmplifier percents.\n\nNote: the transformation used in macOS is not linear, but it is very close and this nuance is thus ignored."; ObjectID = "rNr-97-fnH"; */
"rNr-97-fnH.ibShadowedToolTip" = "Un multiple de la conversion linéaire du volume du système au volume d'origine, compris entre 0 et 1000. \n  \n  \n Remarque: Les transformations utilisées dans macOS ne sont pas linéaires, mais sont très proches, donc les nuances sont ignorées.";

/* Class = "NSButtonCell"; title = "PlayChime"; ObjectID = "rUJ-JZ-9dQ"; */
"rUJ-JZ-9dQ.title" = "PlayChime";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Enable keyboard input sanity checking.\nApparently some boards such as the GA Z77P-D3 may return uninitialised data in EFI_INPUT_KEY with all input protocols. This option discards keys that are neither ASCII, nor are defined in the UEFI specification (see tables 107 and 108 in version 2.8)."; ObjectID = "rxJ-TB-rJc"; */
"rxJ-TB-rJc.ibShadowedToolTip" = "Activez le contrôle d'intégrité du clavier.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Key Map protocols with builtin versions."; ObjectID = "tY1-cE-XtN"; */
"tY1-cE-XtN.ibShadowedToolTip" = "Reconstruisez la touche de fonction Apple et sélectionnez NON.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware output text onscreen in both graphics and text mode. This is typically unexpected as random text may appear over graphical images and cause UI corruption. Setting this option to true will discard all text output when console control is in a different mode from Text.\n\nNote: This option only applies to the System renderer."; ObjectID = "tgx-cE-NIf"; */
"tgx-cE-NIf.ibShadowedToolTip" = "Résoudre le problème de l'écrasement du journal de sortie sur le logo Apple lors du démarrage sans -v.";

/* Class = "NSTabViewItem"; label = "Input"; ObjectID = "tiX-oG-c7h"; */
"tiX-oG-c7h.label" = "Entrée";

/* Class = "NSButtonCell"; title = "ClearScreenOnModeSwitch"; ObjectID = "tqx-Ek-u4V"; */
"tqx-Ek-u4V.title" = "ClearScreenOnModeSwitch";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Secure Boot protocol with a builtin version."; ObjectID = "ub5-qQ-fLN"; */
"ub5-qQ-fLN.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Reinstalls Apple Secure Boot protocol with a builtin version.";

/* Class = "NSTableColumn"; headerCell.title = "Size"; ObjectID = "ufL-Er-oh9"; */
"ufL-Er-oh9.headerCell.title" = "Taille";

/* Class = "NSButtonCell"; title = "AppleDebugLog"; ObjectID = "uqk-49-YG8"; */
"uqk-49-YG8.title" = "AppleDebugLog";

/* Class = "NSButtonCell"; title = "UgaPassThrough"; ObjectID = "vav-dM-ieV"; */
"vav-dM-ieV.title" = "UgaPassThrough";

/* Class = "NSMenuItem"; title = "ACPIMemoryNVS — EfiACPIMemoryNVS"; ObjectID = "wdW-0Y-LKj"; Note = "Do not localize"; */
"wdW-0Y-LKj.title" = "ACPIMemoryNVS — EfiACPIMemoryNVS";

/* Class = "NSTextFieldCell"; title = "ExitBootServicesDelay"; ObjectID = "wxD-TC-lrQ"; */
"wxD-TC-lrQ.title" = "ExitBootServicesDelay";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Remove key unless it was submitted during this timeout in milliseconds.\nAppleKeyMapAggregator protocol is supposed to contain a fixed length buffer of currently pressed keys. However, the majority of the drivers only report key presses as interrupts and pressing and holding the key on the keyboard results in subsequent submissions of this key with some defined time interval. As a result we use a timeout to remove once pressed keys from the buffer once the timeout expires and no new submission of this key happened.\nThis option allows to set this timeout based on the platform. The recommended value that works on the majority of the platforms is 5 milliseconds. For reference, holding one key on VMware will repeat it roughly every 2 milliseconds and the same value for APTIO V is 3-4 milliseconds. Thus it is possible to set a slightly lower value on faster platforms and slightly higher value on slower platforms for more responsive input.\n\nNote: Some platforms may require different values, higher or lower. For example, when detecting key misses in OpenCanopy try increasing this value (e.g. to 10), and when detecting key stall, try decreasing this value. Since every platform is different it may be reasonable to check every value from 1 to 25."; ObjectID = "xNH-9V-3kd"; */
"xNH-9V-3kd.ibShadowedToolTip" = "Intervalle de temps entre chaque touche après l'avoir appuyée (unité: millisecondes) \n Cette option permet de définir ce délai en fonction de votre plateforme. Une valeur recommandée de 5 ms est disponible sur la plupart des plateformes. Pour référence, la détention d'une clé sur VMware se répète toutes les 2 millisecondes environ, tandis que la même valeur pour APTIO V est de 3 à 4 millisecondes. Par conséquent, vous pouvez définir une valeur légèrement inférieure sur une plateforme plus rapide et une valeur légèrement supérieure sur une plateforme plus lente pour améliorer la vitesse de réponse.";

/* Class = "NSMenuItem"; title = "RuntimeCode — EfiRuntimeServicesCode"; ObjectID = "xWU-hM-Ed8"; Note = "Do not localize"; */
"xWU-hM-Ed8.title" = "RuntimeCode — EfiRuntimeServicesCode";

/* Class = "NSMenuItem"; title = "Reserved — EfiReservedMemoryType"; ObjectID = "xhv-Jg-JKE"; Note = "Do not localize"; */
"xhv-Jg-JKE.title" = "Reserved — EfiReservedMemoryType";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nDefault value: 0\nDescription: Adds delay in microseconds after EXIT_BOOT_SERVICES event.\n\nThis is a very rough workaround to circumvent the Still waiting for root device message on some APTIO IV firmware (ASUS Z87-Pro) particularly when using FileVault 2. It appears that for some reason, they execute code in parallel to EXIT_BOOT_SERVICES, which results in the SATA controller being inaccessible from macOS. A better approach should be found in some future. Expect 3 to 5 seconds to be adequate when this quirk is needed."; ObjectID = "yXm-Kd-A6O"; */
"yXm-Kd-A6O.ibShadowedToolTip" = "Vous pouvez contourner le message \n Toujours en attente du périphérique racine\n qui apparaît sur le micrologiciel APTIO IV sélectionné, c'est-à-dire ASUS Z87-Pro, en particulier lorsque vous utilisez FileVault 2. Pour une raison quelconque, le contrôleur SATA n'est pas accessible à partir de macOS. Une meilleure approche devrait être trouvée à l'avenir. Si vous l'utilisez, vous devez le régler pendant 3 à 5 secondes. \n Généralement, conservez la valeur par défaut de 0, ne la modifiez pas par hasard!";

/* Class = "NSButtonCell"; title = "IgnoreTextInGraphics"; ObjectID = "ygR-oy-xAC"; */
"ygR-oy-xAC.title" = "IgnoreTextInGraphics";

/* Class = "NSButtonCell"; title = "AppleImg4Verification"; ObjectID = "ytA-jO-wqX"; */
"ytA-jO-wqX.title" = "AppleImg4Verification";

/* Class = "NSButtonCell"; title = "ReconnectOnResChange"; ObjectID = "zen-LP-Fan"; */
"zen-LP-Fan.title" = "ReconnectOnResChange";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Some types of firmware block partition handles by opening them in By Driver mode, resulting in being unable to install File System protocols.\n\nNote: The quirk is mostly relevant for select HP laptops with no drives listed."; ObjectID = "zhZ-UN-ASB"; */
"zhZ-UN-ASB.ibShadowedToolTip" = "Les ordinateurs portables HP sont définis sur OUI lorsqu'il n'y a pas d'entrée de démarrage dans l'interface de démarrage OpenCore";
